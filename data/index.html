<!DOCTYPE HTML>
<html>
<head>
    <title>ESP8266 Terminal</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        /* seu CSS inteiro aqui (mantido igual) */
        body { 
            font-family: Arial; 
            margin: 0; 
            padding: 20px; 
            background: #2b2b2b; 
            color: #fff; 
        }
        .main-container {
            display: flex;
            gap: 20px;
            height: 400px;
        }
        .terminal-container {
            flex: 2;
        }
        .history-container {
            flex: 1;
            background: #1a1a1a;
            border-radius: 5px;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }
        .history-header {
            padding: 5px;
            background: #333;
            border-radius: 3px;
            margin-bottom: 10px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .history-clear {
            background: #444;
            border: none;
            color: #fff;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
        }
        .history-clear:hover {
            background: #555;
        }
        #history-list {
            overflow-y: auto;
            flex: 1;
        }
        .history-item {
            padding: 5px;
            border-bottom: 1px solid #333;
            font-family: monospace;
            font-size: 0.9em;
            cursor: pointer;
        }
        .history-item:hover {
            background: #333;
        }
        .history-timestamp {
            color: #666;
            font-size: 0.8em;
            margin-right: 5px;
        }
        #terminal { 
            background: #000; 
            padding: 10px; 
            height: 400px; 
            overflow-y: auto; 
            font-family: monospace; 
            margin-bottom: 10px; 
            border-radius: 5px;
        }
        .input-area { 
            display: flex; 
            gap: 10px; 
        }
        input { 
            flex: 1; 
            padding: 10px; 
            border: none; 
            border-radius: 5px; 
            background: #333; 
            color: #fff; 
        }
        button { 
            padding: 10px 20px; 
            background: #0066cc; 
            border: none; 
            color: white; 
            border-radius: 5px; 
            cursor: pointer; 
        }
        button:hover { 
            background: #0052a3; 
        }
        .received { 
            color: #00ff00; 
        }
        .sent { 
            color: #ff9900; 
        }
        .system {
            color: #888;
            font-style: italic;
        }
        .header {
            margin-bottom: 20px;
            padding: 10px;
            background: #333;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .status {
            font-size: 0.9em;
            padding: 5px 10px;
            border-radius: 3px;
            background: #444;
        }
        .status.connected {
            background: #006600;
        }
        .status.disconnected {
            background: #660000;
        }
        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .baudrate-select {
            padding: 5px 10px;
            background: #444;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .baudrate-select:hover {
            background: #555;
        }
        .baudrate-select option {
            background: #333;
        }
        .view-controls {
            display: flex;
            gap: 5px;
        }
        .control-button {
            padding: 5px 10px;
            background: #444;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .control-button:hover {
            background: #555;
        }
        .control-button.active {
            background: #0066cc;
        }
        .stats-bar {
            display: flex;
            gap: 20px;
            padding: 10px;
            background: #1a1a1a;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 0.9em;
        }
        .stat-item {
            display: flex;
            gap: 5px;
        }
        .stat-label {
            color: #888;
        }

        .hex-view {
            font-family: monospace;
        }
        .hex-view .hex {
            color: #888;
            margin-right: 10px;
        }
        .hex-view .ascii {
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="header">
        <h2 style="margin: 0;">ESP8266 Serial Terminal</h2>
        <div class="controls">
            <select id="baudrate" onchange="changeBaudRate()" class="baudrate-select">
                <option value="1200">1200 baud</option>
                <option value="2400">2400 baud</option>
                <option value="4800">4800 baud</option>
                <option value="9600" selected>9600 baud</option>
                <option value="19200">19200 baud</option>
                <option value="38400">38400 baud</option>
                <option value="57600">57600 baud</option>
                <option value="115200">115200 baud</option>
            </select>
            <div class="view-controls">
                <button onclick="toggleHexView()" class="control-button" id="hexButton">HEX</button>
                <button onclick="toggleAutoscroll()" class="control-button" id="scrollButton">Auto-scroll</button>
                <button onclick="exportData()" class="control-button">Exportar</button>
                <button onclick="startFirmwareDump()" class="control-button" id="dumpButton">Dump Firmware</button>
            </div>
            <div id="connection-status" class="status">Desconectado</div>
        </div>
    </div>
    <div class="stats-bar">
        <div class="stat-item">
            <span class="stat-label">Bytes Recebidos:</span>
            <span id="bytesReceived">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Última Mensagem:</span>
            <span id="lastMessageTime">--:--:--</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Mensagens/s:</span>
            <span id="messagesPerSecond">0</span>
        </div>
    </div>
    <div class="main-container">
        <div class="terminal-container">
            <div id="terminal"></div>
            <div class="input-area">
                <input type="text" id="commandInput" placeholder="Digite um comando...">
                <button onclick="sendCommand()">Enviar</button>
            </div>
        </div>
        <div class="history-container">
            <div class="history-header">
                <span>Histórico de Dados</span>
                <button class="history-clear" onclick="clearHistory()">Limpar</button>
            </div>
            <div id="history-list"></div>
        </div>
    </div>
    <script>
        var gateway = `ws://${window.location.hostname}:81/`;
        var websocket;
        var reconnectInterval = null;
        var historyData = [];
        
        const CONFIG = {
            maxHistorySize: 100,
            maxMessageSize: 1024 * 1024,
            dumpChunkSize: 256,
            maxTerminalMessages: 1000,
            reconnectDelay: 2000,
            statsUpdateInterval: 1000,
        };

        const state = {
            isHexView: false,
            autoScroll: true,
            bytesReceived: 0,
            messagesLastSecond: 0,
            lastMessageTime: new Date(),
            isDumping: false,
            dumpStartAddress: 0,
            totalBytesReceived: 0
        };
        
        function changeBaudRate() {
            const baudrate = document.getElementById('baudrate').value;
            if (websocket.readyState === WebSocket.OPEN) {
                websocket.send(`@BAUD=${baudrate}`);
                addToTerminal(`Alterando baudrate para ${baudrate}...`, 'system');
            } else {
                addToTerminal('Erro: Não foi possível alterar o baudrate. Conexão fechada.', 'system');
            }
        }

        window.addEventListener('load', onLoad);

        function onLoad(event) {
            initDOMCache();
            initWebSocket();
            startStatistics();
            
            document.getElementById('commandInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendCommand();
                }
            });
        }

        function updateConnectionStatus(connected) {
            const status = document.getElementById('connection-status');
            if (connected) {
                status.textContent = 'Conectado';
                status.className = 'status connected';
            } else {
                status.textContent = 'Desconectado';
                status.className = 'status disconnected';
            }
        }

        function initWebSocket() {
            console.log('Tentando abrir conexão WebSocket...');
            websocket = new WebSocket(gateway);
            websocket.onopen    = onOpen;
            websocket.onclose   = onClose;
            websocket.onmessage = onMessage;
        }

        function onOpen(event) {
            console.log('Conexão estabelecida');
            updateConnectionStatus(true);
            addToTerminal('Sistema conectado!', 'system');
            const baudrate = document.getElementById('baudrate').value;
            setTimeout(() => {
                websocket.send(`@BAUD=${baudrate}`);
            }, 1000);
            if (reconnectInterval) {
                clearInterval(reconnectInterval);
                reconnectInterval = null;
            }
        }

        function onClose(event) {
            console.log('Conexão fechada');
            updateConnectionStatus(false);
            addToTerminal('Conexão perdida. Tentando reconectar...', 'system');
            if (!reconnectInterval) {
                reconnectInterval = setInterval(initWebSocket, 2000);
            }
        }

        function onMessage(event) {
            addToTerminal(event.data, 'received');
            addToHistory(event.data);
        }

        function addToHistory(message) {
            const timestamp = new Date().toLocaleTimeString();
            historyData.unshift({ timestamp, message });
            
            if (historyData.length > CONFIG.maxHistorySize) {
                historyData.pop();
            }
            
            updateHistoryDisplay();
        }

        function updateHistoryDisplay() {
            const fragment = document.createDocumentFragment();
            
            historyData.forEach(item => {
                const div = document.createElement('div');
                div.className = 'history-item';
                div.innerHTML = `<span class="history-timestamp">[${item.timestamp}]</span> ${item.message}`;
                div.onclick = () => {
                    domElements.commandInput.value = item.message;
                };
                fragment.appendChild(div);
            });
            
            domElements.historyList.innerHTML = '';
            domElements.historyList.appendChild(fragment);
        }

        function clearHistory() {
            historyData = [];
            updateHistoryDisplay();
        }

        function sendCommand() {
            var cmd = document.getElementById('commandInput').value;
            if (cmd) {
                if (websocket.readyState === WebSocket.OPEN) {
                    websocket.send(cmd);
                    addToTerminal('> ' + cmd, 'sent');
                    document.getElementById('commandInput').value = '';
                } else {
                    addToTerminal('Erro: Não foi possível enviar o comando. Conexão fechada.', 'system');
                }
            }
        }

        const domElements = {
            terminal: null,
            bytesReceived: null,
            lastMessageTime: null,
            messagesPerSecond: null,
            commandInput: null,
            historyList: null
        };

        function initDOMCache() {
            domElements.terminal = document.getElementById('terminal');
            domElements.bytesReceived = document.getElementById('bytesReceived');
            domElements.lastMessageTime = document.getElementById('lastMessageTime');
            domElements.messagesPerSecond = document.getElementById('messagesPerSecond');
            domElements.commandInput = document.getElementById('commandInput');
            domElements.historyList = document.getElementById('history-list');
        }

        function startStatistics() {
            setInterval(() => {
                domElements.messagesPerSecond.textContent = state.messagesLastSecond;
                state.messagesLastSecond = 0;
            }, CONFIG.statsUpdateInterval);
        }

        function toggleHexView() {
            state.isHexView = !state.isHexView;
            document.getElementById('hexButton').classList.toggle('active');
            
            const fragment = document.createDocumentFragment();
            Array.from(domElements.terminal.children).forEach(msg => {
                const newLine = createTerminalLine(msg.textContent, msg.className);
                fragment.appendChild(newLine);
            });
            
            domElements.terminal.innerHTML = '';
            domElements.terminal.appendChild(fragment);
        }

        function toggleAutoscroll() {
            state.autoScroll = !state.autoScroll;
            document.getElementById('scrollButton').classList.toggle('active');
        }

        function exportData() {
            const data = historyData.map(item => 
                `[${item.timestamp}] ${item.message}`
            ).join('\n');
            
            const blob = new Blob([data], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `terminal-log-${new Date().toISOString().slice(0,10)}.txt`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        let firmwareChunks = [];
        let isDumping = false;
        let dumpStartAddress = 0;
        let totalBytesReceived = 0;

        function startFirmwareDump() {
            if (isDumping) {
                addToTerminal('Dump já em andamento...', 'system');
                return;
            }

            const dumpButton = document.getElementById('dumpButton');
            dumpButton.classList.add('active');
            isDumping = true;
            firmwareChunks = [];
            dumpStartAddress = 0;
            totalBytesReceived = 0;

            addToTerminal('Iniciando dump do firmware...', 'system');
            requestNextChunk();
        }

        function requestNextChunk() {
            if (!isDumping) return;
            
            websocket.send(`@DUMP=${dumpStartAddress.toString(16)},${CONFIG.dumpChunkSize}`);
            addToTerminal(`Solicitando chunk de memória: 0x${dumpStartAddress.toString(16)}`, 'system');
        }

        function processDumpResponse(data) {
            const parts = data.split(':');
            if (parts.length !== 4 || parts[0] !== '@DUMP') {
                return false;
            }

            const addr = parseInt(parts[1], 16);
            const size = parseInt(parts[2]);
            const hexData = parts[3];

            const bytes = new Uint8Array(hexData.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
            firmwareChunks.push(bytes);
            totalBytesReceived += bytes.length;

            addToTerminal(`Recebido chunk de 0x${addr.toString(16)} (${bytes.length} bytes)`, 'system');

            if (bytes.length === 0 || totalBytesReceived >= 1024*1024) {
                finishDump();
            } else {
                dumpStartAddress += bytes.length;
                setTimeout(requestNextChunk, 100);
            }

            return true;
        }

        function finishDump() {
            isDumping = false;
            document.getElementById('dumpButton').classList.remove('active');

            const totalLength = firmwareChunks.reduce((sum, chunk) => sum + chunk.length, 0);
            const fullArray = new Uint8Array(totalLength);
            let offset = 0;
            for (const chunk of firmwareChunks) {
                fullArray.set(chunk, offset);
                offset += chunk.length;
            }

            const blob = new Blob([fullArray], { type: 'application/octet-stream' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `firmware-dump-${new Date().toISOString().slice(0,10)}.bin`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);

            addToTerminal(`Dump completo! Total de ${totalBytesReceived} bytes salvos.`, 'system');
        }

        function toHex(str) {
            let hex = '';
            let ascii = '';
            for (let i = 0; i < str.length; i++) {
                const charCode = str.charCodeAt(i);
                hex += charCode.toString(16).padStart(2, '0') + ' ';
                ascii += (charCode >= 32 && charCode <= 126) ? str[i] : '.';
            }
            return `<span class="hex">${hex}</span><span class="ascii">${ascii}</span>`;
        }

        function createTerminalLine(message, type) {
            const line = document.createElement('div');
            line.className = type;
            
            if (type === 'received') {
                if (state.isHexView) {
                    line.className += ' hex-view';
                    line.innerHTML = toHex(message);
                } else {
                    line.textContent = message;
                }
            } else {
                line.textContent = message;
            }
            
            return line;
        }

        function addToTerminal(message, type) {
            state.bytesReceived += message.length;
            state.totalBytesReceived += message.length;
            state.lastMessageTime = new Date();
            
            if (type === 'received') {
                state.messagesLastSecond++;
                
                domElements.bytesReceived.textContent = state.bytesReceived;
                domElements.lastMessageTime.textContent = state.lastMessageTime.toLocaleTimeString();
            }

            const line = createTerminalLine(message, type);
            
            const fragment = document.createDocumentFragment();
            fragment.appendChild(line);
            
            domElements.terminal.appendChild(fragment);
            
            if (state.autoScroll) {
                domElements.terminal.scrollTop = domElements.terminal.scrollHeight;
            }

            while (domElements.terminal.children.length > CONFIG.maxTerminalMessages) {
                domElements.terminal.removeChild(domElements.terminal.firstChild);
            }
        }
    </script>
</body>
</html>
)rawliteral";